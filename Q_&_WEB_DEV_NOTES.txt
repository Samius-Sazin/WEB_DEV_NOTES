*****_____INSTRUCTIONS_____*****

1. New Topic Starts with *****_____ name _____*****
2. main topic starts with ~, ~~.
3. sub topic start with *, ** or *** etc.
4. if sub topic has part, starts with '.' one dot.
5. important topic under sub topic starts with '..' double dot
6. If any topics exampl code avl, path will be written before the topic with
	exmpl: < js.api.closure >
7. main topic has 4 space between them
8. sub topic has 1 space between them


*****_____ ShortCuts _____*****
ctrl + shift + o -> find func
ctrl + g -> go to any line


*****_____ Links/Website Part _____*****
.theme forest(website)
.flaticon, fonstawsome
.freepic(illustration)
.unsplash(for pic)
.react-rating
.metarial-Ui (framework like bootstrap, tailwind)


*****_____ Question Part _____*****

~~ Q. HTML, CSS, JavaScript :

* grid vs flex
* diff between html & html5
* about semantic tag
* Which CSS Version started using Media Query? CSS-2
* Purpose of @import in css: import stylesheet into another style sheet
* The default position of an HTML element? static
* Javascript is scripting/programming languag is an interprated lang.
* DOM - Document Object Model
* NODE is part of html DOM
* The InnerText Gives only the text inside a tag
* QuerySelectorAll will return a nodeList
* createElement Create A New Html Element/Tag

** javaScript event bubble: Propagating an event from the lowest to the upward. when we add event handler in many parent/child tags, then after capturing those event from parent to child, the lowest element will trigger first.
	.How to stop event bubbble : by using
		-> event.stopPropagation();

	.stop other events on similar element
		-> event.stopImmediatePropagation(); 

** Event Delegate : 

* OOOP
* prototypical Inheritance:(multi level inheritance) : in js from one obj to enother obj properties shared in a chain method, it is called prototypical inheritance

* API(Application Programming Interface) :
. HTTP get vs post
	.Hypertext Transfer Protocol (HTTP) is designed to enable
	 communications between clients and servers.

	.GET is used to request data from a specified resource.
	 	.GET requests can be cached
		       .remain in the browser history
		       .can be bookmarked
		       .have length restrictions
	.POST is used to send data to a server to create/update a resource
		.POST requests are never cached
		        .do not remain in the browser history
		        .can not be bookmarked
		        .have no length restrictions
. CRUD in rest api : CRUD operations are used to manage data in a
		     structured and efficient way, by providing the
		     functionality to Create, Read, Update and Delete
		     data records.


* XHR = XML HTTP Request

* textContent : All the text contents of a node and all its descendants
* Async Await
* about let vs var
* about declare variable without let/var/const

*** Closure

* Call back function : pass a func to another func as argument

* Bind, Call, Apply

** This -> executionar context.
* Arrow function can't hold 'this' value, take it's immediate
  predecessor's 'this', normal function can

* Window in js : A global variable, window, representing the window
  in which the script is running

* Hoisting, Global Licking




~~ Q. How JS & Browser works: 

* JS is a single-threaded, dynamic type programming language

** How JS run in browser?
* Javascript V8 enginee has Just In time compiler(JIT)
	in it that compile the JS code
	.Firefox use Spider_Monkey enginee to compile JS

* Browser takes HTML & CSS, then make a render tree, then paint, then display.
* Re Render: when we changes anything in css/html broser re render it
	and thes re_paint(re flow of DOM) and display

* Gurbage Collection
* About DNS(Domain Name System) server
*** (Later) JavaScript EventLoop, Concurrency
* How HTTP works
* Heap memory is large mostly unstructured region of memory.

* Session and Local storage difference:
	Both are similar. The difference between them is that the
	LocalStorage data does not expire, whereas sessionStorage
	data is cleared when the page session ends.
* Cookies :
	Coockies are small pieces of text sent to browser by a website
	that user visit. They help that website remember information about
	user's visit, which make it easier to visit the site again and make
	the site more useful to user.

* What is Accessibility?
* Chrome devtools console api
* Call Stack: All previous functions that called this current function
* Regular Expression for beginners in JavaScript

* TypeScript:
	.Typescript is a superset of JavaScript.
	.Typescript code needs to be compiled while JavaScript code
	  doesnâ€™t need to compile.
	.Typescript uses concepts like types and interfaces to describe
	  data being used whereas JavaScript has no such concept.




~~Q. REACT :

* React is a Library, as it gives more flexibility
	.Frameworls are strict
	.Libraries are Flexible 

* SPA: Single Page Application (Like Gmail web page)
	.Advantage of SPA:		
		User Experience
		Optimization
		Client side Rendering

* State of a website: Web Application data that could change.

* Routing:Define the URL and based on URL set different parts of the website.

* Fragment: Return empty tag <></>.

* Evaluated Expression:
	// here {x} is evaluated expression
	const x = 'sami';
	<p> Hi I am {x} <p/>

* React Fiber : documentation from github by acdlite

* React Hook : Used to change/modify/manage State,

* npm/ npx : node package manager/extension

* CLI : Comand Line Interface(Create react app is a cli)

* Babel: Iit's a JavaScript Compiler

* Unidirectional:
	. React Props flow is uniDirectional/One_way
	. React uses one-way data-binding

* Prop Drilling: 
* Props properties are only read only.

* Statefull Component: Component that contains Hook/ Component that has state 
* Stateless Component/Presentational: Component does not have any Hook.

* Props vs State:
	. Props is a value received from its parent component, read only
	. State is a thing that change is website.

* virtual Dom: 
* Diff Algorithm:

* React component Lyfecycle:
	. Mounting (ComponentDidMount)
	. Updating (ComponentDidUpdate)
	. Unmounting (ComponentWillUnmount)











*****_____ Browser and Debug Part _____*****

~~ JS works as both syncronous & asyncronous way :

	< js.x_browser_debug.i_setTimeout >
* setTimeout() :
	// works in Asyncronous way
	// js do other operation, then execute this part
	
	setTimeout(funcName);
	setTimeout(funcName, time(miliSecond));
	setTimeout(func(){..}, time);

	Ex. setTimeout(print(), 5000);//5000 milisecond, 5 second

* fetch also works in Asynchronous way, execute at last.
	Untill then other operations continue in normal way.

	< js.x_browser_debug.ii_setInterval >
* setInterval() :
	.Part 1:
	// like setTimeout(). JS do other operations, then execute this part
	// This part execute and execute, untill we do not stop it manually.
	
	setInterval(funcName);
	setInterval(funcName, time(miliSec))

	.Part 2:
	//this function returns an id, callled interval id.
	//Using this id, setInterval() function can stop by code(not manually)

	const interval_id = setInterval(()=>{
	
	}, time);

~ useState() hook's setCounter() works as Asyncronous



~ alert(), confirm(), prompt() -> all are similar to modal

* alert();
	alert('Your PC has bugs');

* confirm();
	//confirm has 'ok' and 'cancel' button
	//'ok' returns true value, cancel returns 'false' value
	
	const response = confirm('Text...');
	// here response = true/false;

* prompt();
	//prompt has 'ok' and 'cancel' button
	//it also has input are, where it can take input
	//'ok' returns both true & input area value
	//'cancel' returns 'false' value

	const res = prompt('Enter name');
	//here res = false/true('Samius Sazin')




~ Parts of a URL: (href, searchQuery, Domain, Scheme, host, hash...)

* Location object: With this object we can get access of all parts of an URL
	location.host;
	location.href;
	location.hash;
	location.relode();

* History Object:
	history.back(); // go backword
	history.forward(); //go forward

	//refresh the current page
	history.go(); or, history.go(0);

	history.go(1); // go to 1st page,
	history.go(3); // go to 3rd page,
	history.go(-1); // go 1page back,

* Cookies:
	.Has 2 part -> Name & Value
	// get cookies, returns a string
	const cookie_str = document.cookie;

* Local & Session storage:
	.Has 2 part -> Name & Value
	// Both returns either string or json format value
	// If we add something manually -> returns string value
	// System data returns -> json format value

	// get value
	localstorage.getItem('item_name');
	sessionstorage.getItem('item_name');

	// set value
	localstorage.setItem('name', 'value');

	// remove item
	localstorage.removeItem('name');

* Content editable: (defult value 'inherit')
	//now we can edit anything on current web page
	document.body.contentEditable = true;



~ Dev tools Console API:
* Monitor:
	// Monitor any func/button/or_any_element for debug
	monitor(name);
	monitorEvents(name);

	unmonitor(name);
	unmonitorEvents(name);

	// in order to monitor only click & mouse_out events of 'name' element
	monitorEvents(name, ['click', 'mouseout']);

* getEventListeners(object):
	//returns all events applied of an element/object

** Regular Expression:
	.Returns T/F value
	
	//Check if string has number from 0-9 or not
	/[0, 9]/.test(stringName); 
	
	//Check if string has number from A-Z or not
	/[A, Z]/.test(stringName) 




~ TypeScript:

* Declare a variable with data type:
	let num: number = '13'; //error

	let num: number = 13;   //ok
	let name: string = 'Sami'; //ok
	let Bool: boolean = true; //ok

	// Set multiple datatype to a variable
	let x: number | string;

* Array:
	// array of number
	let arr: number[] = [1, 2, 3];

	// array of string
	let arr: string[] = ['a', 'abc', 'sami'];

	// Other operations are similar as JS

* Object:
	// 1st way
	const obj: {}= {
    		name: 'sami',
    		id: 1236
	}	
	
	// 2nd way
	const obj: {name: string, id: number}= {
        	name: 'sami',
        	id: 1236
    	}

	// 3rd way, declare the type first
	type obj_type = {name: string, id: number};
	const obj: obj_type = {
    		name: 'sami',
    		id: 1236
	}


* Normal Function:
	.functions of duplicate name not allowed
	//declare function, add parameter with dataType and initialize
	
	// error
	function add(n1, n2){}
	
	//1. both are ok, 2nd one is preferable
	function add(n1: number, n2: number) {
		return n1+n2
	}
	
	//2. add return type to a function
	function add(n1: number, n2: number): number {
		return n1+n2
	}

	// Call the function and pass argument
	add('Sami', 'Sazin'); //error
	add(3, 5); // ok

	//Return nothing? use void
	function add(n1: number, n2: number): void {
		print(n1+n2);
	}

	// Set multiple datatype to func, parameter..
	function add(n1: number | string, n2: number | string): number | string{
		// Code
	}

	// Object with in a function
	function func6(stud: {name: string, id?: number}): void {
		console.log('Name : ', stud.name);
		console.log('ID   : ', stud.id);
	}

	//call this function
	// func6({name: 'sami', id: 1236});

	
* Arrow Function:
	//normal arrow func
	const func = () => {...}

	// void return type
	const func = (): void => {
    		// code
	}
	
	//number return type
	const func = (): number => {
    		return 10;
	}

	// with parameter
	const func = (n1: number, n2: number): number => n1+n2;
	
	//or
	const func = (n1: number, n2: number): number => {
		return n1+n2;
	}


** Interface:
	.// Declare & Initialize
	interface Student{
		name: string,
		id: number,
		age: number
		graduation_year?: number; //'?' means this point is optional
		
		//some other properties
		courses?: string[]
	}

	//name, id, age must be initialize in s1 & s2, otherwise error
	//But graduation_year is optional, show no error if not initialize
	const s1: Student = {
		name: 'Sami',
		id: 1236,
		age: 21
	}
	const s2: Student = {
		name: 'Samius Sazin',
		id: 1236,
		age: 21,
		graduation_year: 2026,
		
		courses: ['math', 'phy', 'che']
	}


	.// We can do inheritance
	interface Student2 {
		name: string,
		id: number,
		age: number
	}
	interface Alumni2 extends Student2{
		job: string,
		graduation_year: number
	}
	const s3: Alumni2 = {
		job: 'SWE',
		graduation_year: 2026,

		//we must initialize properties of student3 or show error
		name: 'Samius Sazin',
		id: 1236,
		age: 21
	}


* Class in TypeScript
	// declare a class
	class student4 {
		//declare variable
		name: string;
		id: number;
		private _cgpa: number;//declare a private variable

		//constructor
		constructor(name: string, id:number, _cgpa: number){
			this.name = name;
			this.id = id;

			this._cgpa = _cgpa;
		}

		//normal function
		printInfo(){
			console.log('Name : ', this.name);
			console.log('Id   : ', this.id);
		}
		//normal function that returns some value
		returnValue(numb:number): number{
			return numb + numb;
		}
	}

	//create object of 'student4' class
	const s4 = new student4('Sami', 1236, 3.92);
	// s4.printInfo();

























*****_____ REACT Part _____*****

~ Basics:

* Call func, pass argum, receive argum. :
     //to pass arr, object we have to insert them into a variable,
     //then pass them to func
  	const arr = [1, 2 , 3];
  	const obj = {
    		name: "Sami",
    		age: 21,
  	}

     //Call function from jsx, pass arguments
     <Card full_name="Abcd Def" button_text="Click me" array={arr} info={obj}/>

     //The function that will be called & receive those arguments as an Object
     function Card(props){}
	
	.Here props is an object & contains those value
		props = {
			full_name: "Abcd Def",
			button_text: "Click_me"
		}




~ Hooks:
     import { useState, useRef, useCallback, useEffect } from 'react'
	
     * useState Hook:
	func{
	    //its like, let counter = 0;
  	    let [counter, setCounter] = useState(0);
	}
	
	//Change the state of counter
	setCounter(counter => counter + 1);

     * useCallback(fn, dependency)

     * useRef(null)
	const passwordRef = useRef(null);
	
	passwordRef.current?.select();
	passwordRef.current?.setSelectionRange(0, 3);

     * useEffect(fn, dependency)


~ Custom Hooks:
	*

~ Reduce:
	const arr = [1, 2, 3];
	const fnc = (prev, curr) => prev + curr;
	const x = arr.reduce(fnc, 0);	

	